package service;

import db.DatabaseManager;
import model.LogResult;
import thread.FileReaderTask;
import util.LogFileUtil;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;

public class LogAnalyzerService {
    private final DatabaseManager db;

    public LogAnalyzerService() {
        this.db = new DatabaseManager();
    }

    /* ============= Ph√¢n t√≠ch log trong th∆∞ m·ª•c b·∫±ng multithreading ============= */
    public void analyzeLogs(String folderPath) {
        ExecutorService pool = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
        List<Future<LogResult>> futures = new ArrayList<>();

        try {
            // L·∫•y danh s√°ch c√°c file trong th∆∞ m·ª•c
            Files.list(Paths.get(folderPath))
                    .filter(Files::isRegularFile)
                    .forEach(p -> futures.add(pool.submit(new thread.FileReaderTask(p))));
        } catch (IOException e) {
            System.err.println("Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c th∆∞ m·ª•c: " + e.getMessage());
        }

        // Ch·ªù t·∫•t c·∫£ c√°c t√°c v·ª• ho√†n th√†nh v√† thu th·∫≠p k·∫øt qu·∫£
        List<LogResult> results = new ArrayList<>();
        for (Future<LogResult> f : futures) {
            try {
                LogResult r = f.get();
                if (r != null) results.add(r);
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        }
        pool.shutdown();

        // L∆∞u batch v·ªõi Transaction v√†o b·∫£ng log_analysis
        db.saveBatch(results, "log_analysis");
        System.out.println("‚úÖ ƒê√£ ph√¢n t√≠ch " + results.size() + " file v√† l∆∞u DB (log_analysis).");

        // Ghi to√†n b·ªô k·∫øt qu·∫£ v√†o file ana_result.txt
        writeResultsToFile(results, "D:\\InternBE\\log-analyzer_p2\\src\\main\\java\\log_result\\ana_result.txt");
    }

    // Ghi k·∫øt qu·∫£ ph√¢n t√≠ch v√†o file ana_result.txt
    private void writeResultsToFile(List<LogResult> results, String filePath) {
        StringBuilder sb = new StringBuilder();
        sb.append(String.format("%-20s %-12s %-15s %-25s%n", "Filename", "Word Count", "Keyword Count", "Processed At"));
        for (LogResult r : results) {
            sb.append(String.format("%-20s %-12d %-15d %-25s%n",
                    r.getFileName(), r.getWordCount(), r.getKeywordCount(), r.getProcessedAt()));
        }
        try {
            Files.write(Path.of(filePath), sb.toString().getBytes(), StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
            System.out.println("üìÑ ƒê√£ ghi k·∫øt qu·∫£ v√†o file txt");
        } catch (IOException e) {
            System.err.println("L·ªói ghi file txt: " + e.getMessage());
        }
    }

    /* ============= Concurrency: ghi 100 file + DB song song ============= */
    public void write100LogsConcurrently(int N) {

        // Chu·∫©n b·ªã d·ªØ li·ªáu ƒë·ªìng b·ªô (d√πng chung cho 2 t√°c v·ª•)
        List<LogResult> records = new ArrayList<>();
        for (int i = 1; i <= N; i++) {
            String filename = "log_" + i + ".txt";
            int wc = 100 + (int)(Math.random() * 900);
            int kc = 1 + (int)(Math.random() * 10);
            records.add(new LogResult(filename, wc, kc, LocalDateTime.now()));
        }

        ExecutorService pool = Executors.newFixedThreadPool(2);

        Callable<Void> dbTask = () -> {
            db.saveBatch(records, "logs_batch"); // batch insert v√†o b·∫£ng logs_batch
            System.out.println("‚úÖ ƒê√£ ghi " + N + " b·∫£n ghi v√†o DB (logs_batch).");
            return null;
        };

        Callable<Void> fileTask = () -> {
            // Transaction cho ghi file: n·∫øu l·ªói, x√≥a to√†n b·ªô file ƒë√£ ghi tr∆∞·ªõc ƒë√≥
            List<Path> writtenFiles = new ArrayList<>();
            try {
                for (LogResult r : records) {
                    String content = """
                            Filename: %s
                            Word Count: %d
                            Keyword Count: %d
                            Processed At: %s
                            """.formatted(r.getFileName(), r.getWordCount(), r.getKeywordCount(), r.getProcessedAt());
                    Path filePath = Path.of("logs", r.getFileName());
                    util.LogFileUtil.ensureFolderExists("logs");
                    Files.write(filePath, content.getBytes());
                    writtenFiles.add(filePath);
                }
                System.out.println("üìÑ ƒê√£ ghi " + N + " file v√†o th∆∞ m·ª•c ./logs/ (transaction OK)");
            } catch (IOException e) {
                // Rollback: x√≥a to√†n b·ªô file ƒë√£ ghi tr∆∞·ªõc ƒë√≥
                for (Path p : writtenFiles) {
                    try { Files.deleteIfExists(p); } catch (IOException ex) { /* ignore */ }
                }
                System.err.println("L·ªói ghi file, ƒë√£ rollback to√†n b·ªô file ƒë√£ ghi tr∆∞·ªõc ƒë√≥: " + e.getMessage());
            }
            return null;
        };

        try {
            pool.invokeAll(List.of(dbTask, fileTask)); // ch·∫°y 2 t√°c v·ª• song song
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            pool.shutdown();
        }
    }


    /* ============= Concurrency: xem d·ªØ li·ªáu t·ª´ 2 b·∫£ng song song ============= */
    public void showAllConcurrentlyFromTwoTables() {
        db.showAllConcurrentlyFromTwoTables();
    }

    /* ============= CRUD ti·ªán d·ª•ng g·ªçi t·ª´ CLI ============= */
    public void addLog(String filename, int wordCount, int keywordCount) { db.addLog(filename, wordCount, keywordCount); }
    public void showAll() { db.showAll(); }
    public void updateLog(int id, String filename, int wordCount, int keywordCount) { db.updateLog(id, filename, wordCount, keywordCount); }
    public void deleteLog(int id) { db.deleteLog(id); }

    // Ph√¢n t√≠ch log_all.csv b·∫±ng FixedThreadPool, ghi t·ªïng h·ª£p ra file
    public void analyzeLargeLogWithThreadPool(String path) {
        // ƒê·∫∑t ƒë∆∞·ªùng d·∫´n file log c·∫ßn ph√¢n t√≠ch
        path = "D:\\InternBE\\log-analyzer_p2\\src\\main\\resources\\logs\\log_all.csv";
        List<String> lines;
        try {
            // ƒê·ªçc to√†n b·ªô n·ªôi dung file v√†o danh s√°ch d√≤ng
            lines = Files.readAllLines(Paths.get(path));
        } catch (IOException e) {
            // N·∫øu c√≥ l·ªói khi ƒë·ªçc file, in ra l·ªói v√† k·∫øt th√∫c h√†m
            System.err.println("Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c file: " + e.getMessage());
            return;
        }
        // Ki·ªÉm tra file r·ªóng
        if (lines.isEmpty()) {
            System.out.println("File r·ªóng.");
            return;
        }

        // N·∫øu c√≥ header th√¨ b·ªè qua d√≤ng ƒë·∫ßu
        int startIdx = lines.get(0).toLowerCase().contains("timestamp") ? 1 : 0;
        // L·∫•y danh s√°ch d√≤ng d·ªØ li·ªáu (b·ªè qua header n·∫øu c√≥)
        List<String> dataLines = lines.subList(startIdx, lines.size());

        // Kh·ªüi t·∫°o bi·∫øn t·ªïng s·ªë t·ª´ v√† t·ªïng s·ªë keyword
        int totalWordCount = 0;
        int totalKeywordCount = 0;

        // T·∫°o thread pool v·ªõi s·ªë lu·ªìng b·∫±ng s·ªë CPU
        int numThreads = Runtime.getRuntime().availableProcessors();
        ExecutorService pool = Executors.newFixedThreadPool(numThreads);

        // Chia d·ªØ li·ªáu th√†nh c√°c batch cho t·ª´ng lu·ªìng
        int batchSize = (int) Math.ceil((double) dataLines.size() / numThreads);
        List<Future<int[]>> futures = new ArrayList<>();

        // T·∫°o v√† g·ª≠i task cho m·ªói batch
        for (int i = 0; i < numThreads; i++) {
            int from = i * batchSize;
            int to = Math.min(from + batchSize, dataLines.size());
            if (from >= to) break;
            List<String> batch = dataLines.subList(from, to);

            // T·∫°o task cho m·ªói batch: tr·∫£ v·ªÅ m·∫£ng g·ªìm t·ªïng s·ªë t·ª´ v√† t·ªïng s·ªë keyword c·ªßa batch
            Callable<int[]> task = () -> {
                int wc = 0, kc = 0;
                for (String line : batch) {
                    wc += line.trim().isEmpty() ? 0 : line.trim().split("\\s+").length; // ƒê·∫øm s·ªë t·ª´
                    kc += line.split("(?i)error", -1).length - 1; // ƒê·∫øm s·ªë l·∫ßn xu·∫•t hi·ªán "error"
                }
                return new int[]{wc, kc};
            };
            futures.add(pool.submit(task));
        }

        // Thu th·∫≠p k·∫øt qu·∫£ t·ª´ c√°c lu·ªìng v√† c·ªông d·ªìn v√†o t·ªïng
        for (Future<int[]> f : futures) {
            try {
                int[] res = f.get();
                totalWordCount += res[0];
                totalKeywordCount += res[1];
            } catch (InterruptedException | ExecutionException e) {
                // N·∫øu c√≥ l·ªói khi l·∫•y k·∫øt qu·∫£, in ra l·ªói
                e.printStackTrace();
            }
        }

        // ƒê√≥ng thread pool
        pool.shutdown();
        try {
            // Ch·ªù t·ªëi ƒëa 60 gi√¢y ƒë·ªÉ t·∫•t c·∫£ c√°c t√°c v·ª• ho√†n th√†nh
            if (!pool.awaitTermination(60, TimeUnit.SECONDS)) {
                pool.shutdownNow();
            }
        } catch (InterruptedException e) {
            pool.shutdownNow();
        }

        // T·∫°o k·∫øt qu·∫£ t·ªïng h·ª£p v√† ghi ra file ana_result.txt
        List<LogResult> result = List.of(
            new LogResult("log_all.csv", totalWordCount, totalKeywordCount, java.time.LocalDateTime.now())
        );
        writeResultsToFile(result, "D:\\InternBE\\log-analyzer_p2\\src\\main\\java\\log_result\\log_result_fixedThreadPool.txt");
    }

    // Ph√¢n t√≠ch log_all.csv b·∫±ng ForkJoinPool, ghi t·ªïng h·ª£p ra file
    public void analyzeLargeLogWithForkJoin(String path) {
        // ƒê·∫∑t ƒë∆∞·ªùng d·∫´n file log c·∫ßn ph√¢n t√≠ch
        path = "D:\\InternBE\\log-analyzer_p2\\src\\main\\resources\\logs\\log_all.csv";
        List<String> lines;
        try {
            // ƒê·ªçc to√†n b·ªô n·ªôi dung file v√†o danh s√°ch d√≤ng
            lines = Files.readAllLines(Paths.get(path));
        } catch (IOException e) {
            // N·∫øu c√≥ l·ªói khi ƒë·ªçc file, in ra l·ªói v√† k·∫øt th√∫c h√†m
            System.err.println("Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c file: " + e.getMessage());
            return;
        }
        // Ki·ªÉm tra file r·ªóng
        if (lines.isEmpty()) {
            System.out.println("File r·ªóng.");
            return;
        }

        // N·∫øu c√≥ header th√¨ b·ªè qua d√≤ng ƒë·∫ßu
        int startIdx = lines.get(0).toLowerCase().contains("timestamp") ? 1 : 0;
        List<String> dataLines = lines.subList(startIdx, lines.size());

        // S·ª≠ d·ª•ng ForkJoinPool ƒë·ªÉ ph√¢n t√≠ch
        ForkJoinPool pool = new ForkJoinPool();
        LogAnalyzeForkTask task = new LogAnalyzeForkTask(dataLines, 0, dataLines.size());
        int[] resultArr = pool.invoke(task); // K·∫øt qu·∫£: [t·ªïng s·ªë t·ª´, t·ªïng s·ªë keyword]
        pool.shutdown();

        int totalWordCount = resultArr[0];
        int totalKeywordCount = resultArr[1];

        // T·∫°o k·∫øt qu·∫£ t·ªïng h·ª£p v√† ghi ra file ana_result.txt
        List<LogResult> result = List.of(
            new LogResult("log_all.csv", totalWordCount, totalKeywordCount, java.time.LocalDateTime.now())
        );
        writeResultsToFile(result, "D:\\InternBE\\log-analyzer_p2\\src\\main\\java\\log_result\\log_result_forkJoin.txt");
    }

    // Task cho ForkJoinPool: ph√¢n t√≠ch m·ªôt ƒëo·∫°n c·ªßa danh s√°ch d√≤ng
    private static class LogAnalyzeForkTask extends RecursiveTask<int[]> {
        private static final int THRESHOLD = 500; // ng∆∞·ª°ng chia nh·ªè
        private final List<String> lines;
        private final int start, end;

        LogAnalyzeForkTask(List<String> lines, int start, int end) {
            this.lines = lines;
            this.start = start;
            this.end = end;
        }

        @Override
        protected int[] compute() {
            // N·∫øu s·ªë d√≤ng nh·ªè h∆°n ng∆∞·ª°ng, x·ª≠ l√Ω tr·ª±c ti·∫øp
            if (end - start <= THRESHOLD) {
                int wc = 0, kc = 0;
                for (int i = start; i < end; i++) {
                    String line = lines.get(i);
                    wc += line.trim().isEmpty() ? 0 : line.trim().split("\\s+").length; // ƒê·∫øm s·ªë t·ª´
                    kc += line.split("(?i)error", -1).length - 1; // ƒê·∫øm s·ªë l·∫ßn xu·∫•t hi·ªán "error"
                }
                return new int[]{wc, kc};
            } else {
                // N·∫øu s·ªë d√≤ng l·ªõn, chia ƒë√¥i v√† x·ª≠ l√Ω song song
                int mid = (start + end) / 2;
                LogAnalyzeForkTask left = new LogAnalyzeForkTask(lines, start, mid);
                LogAnalyzeForkTask right = new LogAnalyzeForkTask(lines, mid, end);
                left.fork(); // ch·∫°y nh√°nh tr√°i song song
                int[] rightRes = right.compute(); // x·ª≠ l√Ω nh√°nh ph·∫£i
                int[] leftRes = left.join(); // l·∫•y k·∫øt qu·∫£ nh√°nh tr√°i
                // C·ªông k·∫øt qu·∫£ hai nh√°nh
                return new int[]{leftRes[0] + rightRes[0], leftRes[1] + rightRes[1]};
            }
        }
    }
}
